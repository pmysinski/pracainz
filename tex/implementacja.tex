\chapter{Projekt programu i implementacja}

Ten rozdział przedstawia dokładny proces implementacji programu \emph{DBLatexRaport,}  który ma na celu spełnienia wymagań oraz celów zawartych we wstępie.  Osoba po przeanalizowaniu poniższego materiału, będzie w stanie w przyszłości ulepszyć o nowe funkcję istniejący już program lub stworzyć nowy, podobny program w innym języku programowania, który będzie w stanie obsłużyć istniejące już szablony. 
\par
 Wyjaśnione zostaną podjęte decyzje oraz postępowania przy pisaniu danego kodu, aby w pełni oddać idee tworzenia tego programu. Sekcję tę, można więc potraktować jako pewien samouczek, który jednak wymaga minimalnej znajomości języka programowania \emph{JAVA}. Pominięte też zostaną kwestie związane z importem podstawowych bibliotek, czy też wszelkie obsługi wyjątków, które mogą zaistnieć przy złej obsłudze programu. Cała uwaga zostanie skupiona tylko i wyłącznie na kodzie, przy poprawnym wykonaniu. W razie potrzeby dokładnej analizy cały kod programu znajduje się w załączniku 2.
 \par
 Wszelki kod przedstawiony w tym rozdziale zawierający z lewej stronie numery linii, znajduje się w programie. Numery te  odzwierciedlają dokładne położenie danej linii kodu w programie. Dodatkowo pełna dokumentacja kodu w języku angielskim znajduje się w załączniku 2.

\section{Algorytm działania systemu raportowania}

W poprzednim rozdziale przedstawiony został proces tworzenia samych szablonów. W tej sekcji natomiast skupiona zostanie uwaga na tym jak zaprojektować system uzupełniania tych szablonów. Między innymi właśnie o tym jak umieszczać informacje w szablonie na temat selekcjonowania danych czy też jak wygenerować odpowiednią strukturę danych.

\subsection{Algorytm parsowania}
Aby szablon raportu został uzupełniony o potrzebne dane, musi on posiadać pewną informację o tym, co i w jakiej formie należy w nim zapisać.  Program musi przeszukać szablon w celu znalezienia tej informacji i przeanalizowanie jej, aby wywołać odpowiednie procedury na rzecz danego szablonu. Jako, że informacja ta przeznaczona jest tylko dla programu przeszukującego, zapis tej informacji powinien być ignorowany przez środowisko kompilacji raportów.  W wybranym wcześniej środowisku LaTeX znajduje się komenda \texttt{iffalse} oraz jej zamknięcie \texttt{fi} dzięki której wszystko pomiędzy zostanie zignorowane w czasie kompilacji dokumentów. Zapis ten dodatkowo może zajmować wiele linii:
\begin{lstlisting}
\iffalse 
...
...
\fi
\end{lstlisting}
Jeśli polecenie jest w stanie zmieścić się w jednej linii, można użyć \% aby za komentować tę linię, co przyniesie dokładnie taki sam efekt.
\par
Kolejnym krokiem jest ustalenie struktury informacji, która powinna zawierać instrukcje do stworzenia wywołań środowisk z danymi przesłanymi jako parametry. Instrukcjami tymi są po kolei: nazwa środowiska, grupowanie pól oraz selekcja danych. Utworzony został  na potrzeby tego programu standardowy zapis w różnych wariantach z wykorzystaniem znaków \texttt{@} jako separatorów oraz informacji o zakończeniu instrukcji \texttt{@END@}:\vspace{5mm}
\begin{enumerate}
\item Pusty - Polecenie do bazy danych, które nie zwraca żadnych danych.
\begin{lstlisting}
\iffalse 
@@@@Polecenie do bazy danych@END@
\fi
\end{lstlisting}

\item Prosty - Polecenie do bazy danych, zwracające wyselekcjonowane dane pod daną nazwą środowiska
\begin{lstlisting}
\iffalse 
@@Nazwa środowiska@@Selekcja danych@END@
\fi
\end{lstlisting}

\item Z grupowaniem - Polecenie do bazy danych, zwracające wyselekcjonowane dane pod daną nazwą środowiska dodatkowo z informacją o grupowaniu, która składa się z cyfr oraz przecinków.
\begin{lstlisting}
\iffalse 
@@Nazwa środowiska@Grupowanie@@Selekcja danych@END@
\fi
\end{lstlisting}
\end{enumerate}

\subsection{Selekcjonowanie danych}

Wybieranie danych z bazy odbywać się będzie na poziomie połączenia z wybranym silnikiem bazodanowym. Oznacza to, że zapytania o dane muszą zostać napisane tak, by interpreter poleceń SQL danego silnika był w stanie je przetworzyć i wykonać tak by uzyskać potrzebne dane. Oznacza to, że zapytanie zapisane w danej instrukcji wywoływane jest bez żadnych zmian na bazie danych z którą połączona jest aplikacja.

\subsection{Struktura uzupełnianych danych}

Środowiska utworzone w szablonach są w stanie same, za pomocą argumentów, uzupełnić dane miejsca, o daną wartość. Zadaniem programu jest utworzyć z wyselekcjonowanych danych, wywołanie tego środowiska dla każdego rekordu pobranego z bazy danych. Wywołanie środowiska odbywa się poprzez polecenie:
\begin{lstlisting}
\nazwasrodowiska{parametr1}{parametr2}{parametr3} ...
\end{lstlisting}

Taka struktura może być wynikiem prostego wariantu polecenia:
\begin{lstlisting}
\iffalse@@parametrRekrutacyjny@@
SELECT klucz,wartosc FROM setup_aligeza
@END@\fi
\end{lstlisting}
Gdzie wynikiem takiego polecenia będzie:
\begin{lstlisting}
\parametrRekrutacyjny{rokAkademicki}{2014/2015}
\parametrRekrutacyjny{czyUwzglednicDateWydaniaDecyzji}{N}
\parametrRekrutacyjny{instytutNazwa}{Instytut Techniczny}
\end{lstlisting}

Na potrzeby systemu rekrutacji, musiała zostać stworzona dodatkowa struktura, pełniąca funkcję grupowania. Wykorzystana może być także w przypadku gdy rekordy zwrócone z bazy danych zawierają więcej niż 9 pól, ze względu na to, że środowiska mogą być wywoływane maksymalnie od 9 argumentów. Poniżej przedstawiona zostanie tylko struktura z krótkim wprowadzeniem. Dokładny opis jej tworzenia znajduje się w implementacji.

Strukturę grupowania odzwierciedla struktura drzewa. Wywołanie środowiska z dodaną dużą literą alfabetu łacińskiego na końcu nazwy rozpoczyna grupę, natomiast wywołanie środowiska z dodaną frazą \texttt{end} na początku nazwy, kończy daną grupę. Uwagę należy zwrócić na fakt, iż w alfabecie łacińskim jest 26 znaków, co ogranicza ilość grup do 26. Na przykładzie drzewa może wyglądać to następująco:

\iffalse
\dirtree{%
 .1 \textbackslash NazwaA.
 .2 \textbackslash NazwaB.
 .3 \textbackslash Nazwa.
 .3 \textbackslash Nazwa.
 .3 \ldots.
 .2 \textbackslash endNazwaB.
 .2 \textbackslash NazwaB.
 .3 \textbackslash Nazwa.
 .3 \textbackslash Nazwa.
 .2 \textbackslash endNazwaB.
 .1 \textbackslash endNazwaA.
}\fi
\vspace{5mm}
Każde grupujące środowisko wymaga co najmniej 1 parametru, który zabierany jest z pól rekordów pobranych z bazy danych. Pole dla wszystkich rekordów w danej grupie jest takie samo dlatego jest ono właśnie przerzucane do wywołania środowiska grupy.
Poniżej prosty przykład ukazujący dane zachowanie:
\begin{lstlisting}
\nazwasrodowiskaA{pole1}
\nazwasrodowiska{pole2}{pole3}{pole4}...
\nazwasrodowiska{pole2}{pole3}{pole4}...
...
\endnazwasrodowiskaA
\end{lstlisting}

\subsection{Wywołanie kompilacji szablonu}

Ostatecznie aby wytworzyć dokument w \emph{PDF} należy go skompilować wybranym kompilatorem. Do tego posłuży polecenie powłoki systemu Windows. Poniżej przykładowe wywołanie kompilatora LaTeX:
\begin{lstlisting}
cmd /c start texlive\2010min\bin\win32\pdflatex.exe 
--output-directory=output/ output/main.tex
\end{lstlisting}


\section{Wybór języka oraz środowiska programistycznego }

Pierwszym podstawowym kryterium wyboru języka programowania, w tym projekcie, jest fakt posiadania przez język gotowych bibliotek obsługujących połączenie z serwerem bazodanowym. Cała reszta wymagań takich jak obsługa operacji na plikach, operacje na łańcuchach tekstu, obiektowość języka czy też multiplatformowość schodzą na drugi plan, ze względu na to, że każdy współczesny język posiada większość podstawowych funkcjonalności. 
\par Na uczelni wykorzystywany jest serwer bazodanowy o silniku \emph{Firebird 2.5}. Najpopularniejsze języki programowania, które obsługują połączenie z tym serwerem to \cite{Dokumentacja_Firebird}:
\begin{itemize}
\item JAVA
\item C++
\item C\#
\item Delphi
\item Perl
\item Python
\item wszystkie języki obsługujące połączenie z \emph{ODBC (Open DataBase Connectivity)} 
\end{itemize}
\vspace{5mm}
We wszystkich powyższych językach jest wstanie powstać potrzebny program, jednak najlepszym wyborem okazał się język \emph{\textbf{JAVA}} \cite{kompediumjava}, ze względu na wiele zalet:
\begin{itemize}
\item prostota importu bibliotek połączenia z serwerem bazodanowym. Dodatkowo na jednym interfejsie można obsłużyć połączenia z innymi silnikami bazodanowymi.
\item multiplatformowość
\item obiektowość
\item wiele zaimplementowanych już funkcji, które zostaną wykorzystane w programie.
\item łatwość pisania kodu
\item wystarczająca wydajność na potrzeby projektu
\end{itemize}
\vspace{5mm}
\par
Natomiast na środowisko w jakim powstanie projekt wybrany został program \emph{\textbf{NetBeans 8.0.2 }} ze względu wiele przydanych funkcjonalności oraz  prostotę obsługi. Dodatkowo posiada on pełną dokumentację jak i wiele samouczków w Internecie \cite{NetBeans_Platform}. 

\section{Utworzenie projektu i jego struktury}

Środowisko \emph{NetBeans 8.0.2} posiada funkcję utworzenia projektu typu \emph{JAVA Application}. Automatycznie stworzony zostanie package o nazwie projektu \emph{DBLatexRaport} oraz klasa, o tej samej nazwie, zawierającą metodę \texttt{main(String[] args)}. Od tej metody program zacznie swoje wykonanie. Tak więc, w metodzie tej, także będą umieszczane deklaracje wszystkich obiektów klas głównych oraz ich inicjalizacja. 
\par 
Aplikacja, oprócz swojej głównej klasy zawierającej metodę \texttt{main()}, będzie wymagała podziału na moduły, które będą odzwierciedlane poprzez odpowiednie klasy. Wymagane do działania będą:
\begin{itemize}
\item klasa Config - moduł obsługi pliku konfiguracyjnego 
\item klasa DBHandle - moduł obsługi połączenia z bazą danych.
\item klasa Templates - moduł obsługi szablonów.
\item klasa LatexCompiler -  moduł obsługi wywoływania kompilatora szablonów.
\end{itemize}
\vspace{5mm}
Podczas tworzenia programu może okazać się, że przydadzą się jeszcze dodatkowe klasy pomocnicze, przechowujące pewne dane w spójnej strukturze. Zastosowanie takich klas, znacznie ułatwi i przyspieszy pracę z danymi. Klasy te dokładnie opisane zostaną w jednej z następnych podsekcji:
\begin{itemize}
\item klasa ParsedSQLInfo - do przechowywania informacji o selekcji danych
\item klasa RecordSet - do przechowywania pobranych danych z bazy.
\end{itemize}

\section{Zarządzanie konfiguracją - klasa Config}

Większość programów przed uruchomieniem wymaga konfiguracji. Konfiguracje można przeprowadzić na wiele sposobów jednak najodpowiedniejszym sposobem do tej aplikacji będzie plik konfiguracyjny, wczytywany przed uruchomieniem programu. Taki plik powinien posiadać informacje przypisane do zmiennych o stałych nazwach. Dobrym zwyczajem jest, aby plik konfiguracyjny posiadał też możliwość pisania komentarzy. Dzięki komentarzom, łatwiej jest skonfigurować dany program.
\par
Autorskim pomysłem jest dodatkowa funkcja pliku konfiguracyjnego, jaką jest aby plik ten był jednocześnie plikiem wsadowym. Polecenia powłoki systemu rozpoczynają plik, i kończą się na poleceniu \texttt{EXIT}. Następnie od lini \emph{\#dbLatexRaportConfig} rozpoczyna się zapis zmiennych konfiguracyjnych.
\par
Klasa ta została tak zaprojektowana by mogła przyjąć wszelkie nazwy zmiennych oraz ich wartości w postaci łańcuchów znakowych, a następnie za pomocą odpowiedniej metody można było w środku programu odwołać się do wartości danej zmiennej po jej nazwie. Dla przykładu zdeklarowanie zmiennej za pomocą jej nazwy oraz zaraz po znaku "\texttt{=}"  jej wartości:
\begin{lstlisting}
user=SYSDBA
\end{lstlisting}
Następnie po utworzeniu się obiektu klasy Config i załadowaniu poprawnie pliku konfiguracyjnego powinniśmy móc pobrać wartość  zmiennej \texttt{user} poprzez wywołanie odpowiedniej metody. Oczywiście dla braku zmiennej, powinna zwracać pustą wartość i informować o tym użytkownika.
\begin{lstlisting}
Config cfg = new Config("dblatexraportconfig.bat");
System.out.println(cfg.getString("user"));
\end{lstlisting}

Podejściem do zaprojektowania tej klasy można uznać za metodę od ogółu do szczegółu. Na początek potrzeba zaimportować odpowiednie pakiety do obsługi plików, a następnie pozostaje już tylko ustalić składowe, zaimplementować sparametryzowany konstruktor klasy oraz metodę zwracającą daną zmienną. Składowe klasy muszą przede wszystkim przechowywać załadowane zmienne z pliku w pamięci. Łatwym sposobem realizacji tego jest użycie zmiennych tablicowych o typie \emph{String} czyli łańcuchów znaków. Dla każdego indeksu przechowywana będzie informacja o nazwie oraz wartości zmiennej. 
\begin{lstlisting}[numbers=left,firstnumber=23]
public  class Config {

      String[] strindex;
      String[] value; 
\end{lstlisting}

Następnie konstruktor klasy z jednym parametrem posłuży jako metoda otwarcia pliku i załadowania wszystkich zmiennych. Parametrem będzie nazwa pliku konfiguracyjnego. Konstruktor klasy w \emph{JAVA}'e musi nazywać się tak jak klasa. Po uruchomieniu konstruktora otwieramy plik wykorzystując dostępne klasy obsługi plików.
\begin{lstlisting}[numbers=left,firstnumber=39]
public Config(String path){
 File cfg = new File(path);
 BufferedReader in = new BufferedReader(
 new InputStreamReader(
 new FileInputStream(cfg), "UTF-8"));
\end{lstlisting}
Do odczytu przygotować należy pewien bufor oraz zmienne pomocnicze:
\begin{lstlisting}[numbers=left,firstnumber=55]
 String tmp;
 String[] strindextmp = new String[50];
 String[] valuetmp = new String[50];
 int count=0;
 int flag = 0;
\end{lstlisting}

Następnie potrzebna jest pętla odczytująca plik linia po linii. Pętla zakończy się po odczytaniu całego pliku, przekazując odczytaną linie do jednej iteracji w pętli. Wewnątrz pętli pierwszym krokiem jest sprawdzenie czy linia zawiera flagę \texttt{\#dbLatexRaportConfig} by móc zacząć odczytywać zmienne poprzez ustawienie zmiennej \texttt{flag} na wartość 1. Pozostaje już tylko sprawdzić czy linia nie jest pusta oraz czy nie jest komentarzem, aby móc zapisać zmienne poprzez wyłączenie z linii nazwy (cała linia do znaku "=") oraz wartości zmiennej (cała linia od znaku "=") do aktualnego indeksu bufora. Ostatecznie potrzeba zwiększyć indeks bufora o 1 i zakończyć iteracje.
\begin{lstlisting}[numbers=left,firstnumber=60]
while ((tmp = in.readLine()) != null) {
 if(flag == 0 && tmp.equals("#dbLatexRaportConfig"))
  flag = 1;
 if(flag == 1 && tmp.indexOf('#') != 0
 && tmp.length() != 0 && tmp.indexOf('=') != -1){
  strindextmp[count] = tmp.substring(0,tmp.indexOf('='));
  valuetmp[count] = tmp.substring(tmp.indexOf('=')+ 1,tmp.length());
  count++;
 }
}
\end{lstlisting}

Na koniec zamykany jest plik i alokowana jest pamięć o dokładnie \emph{count} elementów dla składowych klasy. Ostatecznie przepisywany jest cały bufor do tych składowych.
\begin{lstlisting}[numbers=left,firstnumber=70]
in.close();
        
strindex = new String[count];
value = new String[count];
                  
for(int i=0;i < count; i++){
 strindex[i] = strindextmp[i];
 value[i] = valuetmp[i];
}
\end{lstlisting}

Pozostaje zaimplementowanie metody zawracającej wartość zapamiętanej zmiennej. Do tego posłuży metoda o nazwie \texttt{getString} i parametrze \texttt{String name}. Parametr jest kluczem do wartości zmiennej, która zostanie zwrócona.  Aby znaleźć tą wartość należy przejrzeć tablicę nazw zmiennych i porównać każdą wartość z nazwą szukanej zmiennej. Jeśli znaleziony zostanie odpowiednik klucza, oznaczać to będzie, że pod tym samym indeksem w tablicy wartości znajduje się szukana zmienna, którą zwróci metoda. W przypadku braku zmiennej metoda zwróci pustą wartość i wyświetli informacje o jej braku.

\begin{lstlisting}[numbers=left,firstnumber=169]
public  String getString(String name){
 for(int i=0;i < value.length; i++){
   if(strindex[i].indexOf(name) == 0)
    return(value[i]);
  }
 System.out.print("CONFIG VARIABLE ERROR: " + name + "\n");
 return("");
}
\end{lstlisting}

\section{Klasy typu kontener}

Przed przystąpieniem do tworzenia reszty głównych klas programu, potrzebne będzie stworzenie dwóch klas pomocniczych zawierających pewną strukturę danych oraz interfejs. Posłużą one do zapewnienia łatwej wymiany danych pomiędzy modułami. 

\subsection{Klasa ParsedSQLInfo}

Pierwszą taką klasą będzie struktura reprezentująca informację o selekcji danych, wczytaną z szablonu. Klasa zostanie nazwana \texttt{ParsedSQLInfo} i zawierać będzie następujące składowe wyczerpujące wszelkie informacje na temat selekcji:

\begin{lstlisting}[numbers=left,firstnumber=11]
public class ParsedSQLInfo {
 String query;
 String name;
 String group;
 int index;
 String data;
\end{lstlisting}
Odpowiednio:
    \begin{itemize}
    \item \texttt{query} - polecenie SQL
    \item \texttt{name} - nazwa środowiska.
    \item \texttt{group} - grupowanie
    \item \texttt{index} - miejsce zapisu do pliku
    \item \texttt{data} - wygenerowane dane dla tego zapytania.
    \end{itemize}

Do klasy został stworzony konstruktor sparametryzowany, który okaże się przydatny przy tworzeniu obiektu:
   
\begin{lstlisting}[numbers=left,firstnumber=21]
public ParsedSQLInfo(String query, String name,String group, int index) {
 this.query = query;
 this.name = name;
 this.group = group;
 this.index = index;
 this.data = "";
}
\end{lstlisting}

Oraz podstawowy interfejs do  pobrania lub zmiany danych:
\begin{lstlisting}[numbers=left,firstnumber=30]
public int getIndex() {return index;}
public String getQuery() {return query;}
public String getName() {return name;}
public String getGroup() {return group;}
public String getData() {return data;}
public void setIndex(int index) {this.index = index;}
public void setQuery(String query) {this.query = query;}
public void setName(String name) {this.name = name;}
public void setGroup(String group) {this.group = group;}
public void setData(String data) {this.data = data;}
\end{lstlisting}

\subsection{Klasa RecordSet}
Druga klasa typu kontener przechowywać będzie wyniki zapytań SQL w postaci listy rekordów. Każdy rekord natomiast będzie reprezentowany jako tablica zmiennych typu \texttt{String} o danej długości. Składowe wyczerpujące wszelkie informacje wyglądać będą następująco:

\begin{lstlisting}[numbers=left,firstnumber=13]
public class RecordSet {

ArrayList<String[]> val;
int m;
\end{lstlisting}

Jak w poprzedniej klasie, zaimplementowany został interfejs oraz konstruktor służący do zainicjowania obiektu ilością kolumn w rekordach:
 \begin{lstlisting}[numbers=left,firstnumber=18]
RecordSet(int columncount){
val = new ArrayList<String[]>();
m = columncount;
}
 \end{lstlisting}

Interfejs wymagał by łatwo można było nadpisać daną wartość oraz pobrać w zależności od numeru rekordu oraz numeru pola. Zwrócić uwagę należy na to, iż przy zapisie nowych rekordów, lista automatycznie się poszerzy. Dodatkowo dodana jest możliwość pobrania ilości rekordów czy też pól w jednym rekordzie.
 \begin{lstlisting}[numbers=left,firstnumber=23]
void setVal(String str,int i, int j){
 while(val.size() <= i)
  val.add(new String[m]);
 val.get(i)[j]=str;
}
String getVal(int i, int j){return(val.get(i)[j]);}   

int get_rows(){return(val.size());}
int get_cols(){return(m);}
\end{lstlisting}

\section{Obsługa połączenia z bazą danych - klasa DBHandle}

Stworzenie klasy obsługującej połączenie z bazą danych oraz wywołania poleceń na tej bazie, wymagało będzie zaimportowania dodatkowych bibliotek. W języku \emph{Java} znajduje się moduł \emph{ JDBC(TM) Database Access}, który zostanie wykorzystany w implementacji tej klasy. Dokładna dokumentacja tego modułu znajduje się na stronie \emph{http://www.cs.mun.ca/~michael/java/jdk1.1.5-docs/guide/jdbc/index.html}. Poniżej przedstawiona zostanie jedynie idea zastosowanie tego rozwiązania oraz implementacja wykorzystująca ten moduł.
\subsection{Wykorzystanie JDBC(TM) Database Access}

Dzięki wykorzystaniu \emph{ JDBC(TM) Database Access} \cite{Dokumentacja_Jaybird} obsługa połączeń z wieloma rodzajami baz danych staje się prosta. Idea tego rozwiązania jest taka aby dla każdego rodzaju bazy danych interfejs połączenia był dokładnie taki sam. Interfejs ten dostępny jest przez klasę \texttt{java.sql.DriverManager}, pozwalającą załadować odpowiednią bibliotekę dla wybranego silnika bazodanowego, zwracając obiekt z takim samym interfejsem dla każdej możliwej bazy danych. 
\par
W przypadku pracy z serwerem \emph{Firebird 2.5} potrzebne będzie jeszcze zaimportowanie do projektu odpowiedniego pliku \emph{jaybird-full-2.2.9.jar}, który został specjalnie przygotowany dla połączeń z tym serwerem. Jest on do pobrania z oficjalnej strony "\emph{http://www.firebirdsql.org/}". W razie potrzeby połączenie z innym rodzajem bazy danych, wystarczy w analogiczny sposób zaimportować biblioteki przygotowane przez twórców danego serwera a następnie tylko wywołać je poprzez klasę \texttt{java.sql.DriverManager} bez większej ingerencji w kod źródłowy programu.

\subsection{Implementacja klasy}

Posiadając zaimportowaną odpowiednią bibliotekę można rozpocząć implementację. Klasa obsługująca połączenie powinna posiadać metody do połączenia się z serwerem oraz metodę do wysłania zapytania i pobrania danych, które zwróci dane polecenie. Do przechowywania zwróconych danych użyta zostanie wcześniej stworzona klasa kontener \texttt{RecordSet}. Próba nawiązania połączenia będzie odbywała się w czasie tworzenia obiektu w konstruktorze sparametryzowanym, zawierające parametry dotyczące połączenia, takie jak użytkownik, hasło, adres czy port.
\par
Składowe klasy powinny przechowywać obiekt obsługujący aktualne połączenie oraz obiekt obsługujący wysyłanie zapytań do serwera:
 \begin{lstlisting}[numbers=left,firstnumber=19]
public class DBHandle {
 Connection con;
 Statement stmt; 
  \end{lstlisting}
  Zgodnie ze wcześniejszymi ustaleniami, nawiązanie połączenia odbywać się będzie w konstruktorze klasy. Do konstruktora przekazaną zostaną wszystkie informacje możliwe informacje na temat połączenia w postaci parametrów:
   \begin{lstlisting}[numbers=left,firstnumber=44]
   public DBHandle(String engine,String hostname,
   String port, String dbpath,String encoding,
    String user,  String password){
   \end{lstlisting}
Odpowiednio:
    \begin{itemize}
    \item \texttt{engine} - Nazwa silnika bazodanowego
    \item \texttt{hostname} - adres serwera
    \item \texttt{port} - port serwera
    \item \texttt{dbpath} - ścieżka do bazy danych lub po prostu nazwa
    \item \texttt{encoding} - Kodowanie po stronie serwera łańcuchów znakowych.
    \item \texttt{user} - Nazwa użytkownika
    \item \texttt{password} - hasło
    \end{itemize}

Następnie w ciele konstruktora nawiązane zostanie połączenie poprzez  tak zwany \emph{Connection String}, czyli łańcucha znaków w odpowiednim formacie zawierającego informacje na temat połączenia, które ma zinterpretować klasa \texttt{java.sql.DriverManager} i spróbować nawiązać połączenie. \emph{Connection String} przyjmuje wiele zmiennych także w zależności od rodzaju połączenia. Poniżej pokazany zostanie przypadek nawiązania połączenia z serwerem \emph{Firebird 2.5} po adresie IP lub nazwie hosta. Najpierw ładowny jest sterownik \texttt{org.firebirdsql.jdbc.FBDriver}, następnie tworzony jest \texttt{Connection String} z parametrów przekazanych do konstruktora i ostatecznie wywoływana jest próba połączenia przez metodę \texttt{getConnection()}:
   \begin{lstlisting}[numbers=left,firstnumber=61]
if(engine.equals("firebirdsql")){
 try {
  Class.forName("org.firebirdsql.jdbc.FBDriver");
 } catch (ClassNotFoundException ex) {
  System.out.println( "Data Base connection driver error for 
  Firebird \nEXCEPTION: " + ex.getMessage( ) );
 }
  constr = "jdbc:" + engine + ":" + hostname + ":" + port + "/"
   + dbpath + "?encoding=" + encoding;
  con = DriverManager.getConnection(constr,user,password);
}
\end{lstlisting}

Na koniec jeśli połączenie się powiedzie tworzymy obiekt odpowiedzialny za wywoływanie zapytań na danym połączeniu i referencję do niego zapisujemy pod składową \texttt{stmt}.
\begin{lstlisting}[numbers=left,firstnumber=94]
stmt = con.createStatement(
ResultSet.TYPE_FORWARD_ONLY,
ResultSet.CONCUR_READ_ONLY);
System.out.println( "Connection to database: OK" );
}
\end{lstlisting}

Pozostaje zaimplementować metodę odpowiedzialną za wysyłanie zapytania i pobieranie danych na obecnym połączeniu. Metoda będzie przyjmować parametr w postaci zapytania SQL i zwracać obiekt klasy \texttt{RecordSet} uzupełniony o wszystkie rekordy zwrócone przez zapytanie.
\begin{lstlisting}[numbers=left,firstnumber=122]
public  RecordSet executeSQL2(String SQL){
\end{lstlisting}

Następnie deklaracje potrzebnych zmiennych oraz wywołanie polecenia na bazie danych. Wyniki zapytania zwracane są do klasy \texttt{ResultSet}. Dodatkowo uzyskane zostaną jeszcze meta dane na temat ilości kolumn w pobranych rekordach. 
\begin{lstlisting}[numbers=left,firstnumber=123]
int n=0,m=0,i=0,j=0;
String tmp;
RecordSet ret = null;
ResultSet rs = stmt.executeQuery( SQL );
rsmd = rs.getMetaData();
m=rsmd.getColumnCount();
\end{lstlisting}

Ze względu na brak odpowiedniego interfejsu ze strony obiektu klasy \texttt{ResultSet} na potrzeby dalszych manipulacji danymi, wszystkie rekordy zostaną przepisane do obiektu klasy \texttt{RecordSet}. W razie wartości  \texttt{null} jakiegoś pola w rekordzie, zastąpiona ona będzie łańcuchem znaków:
\begin{lstlisting}[numbers=left,firstnumber=135]
while(rs.next()) {
 for(j=0;j < m; j++){
  tmp = rs.getString(j+1);
  if(tmp != null){
   ret.setVal(tmp, i, j);
  }
  else
   ret.setVal("null", i, j);
  }
 i++;
}   
rs.close();
return(ret);
}
\end{lstlisting}


\section{Zarządzanie szablonami - klasa Templates}

Wielkość i złożoność tej klasy wymaga podzielenia jej opisu na kilka podsekcji. Należy także dodać, że jest to jedyna klasa w której dochodzi do jakichkolwiek manipulacji danymi. Proces działania tej klasy można pokazać na krótkiej liście:
\vspace{5mm}
    \begin{enumerate}
    \item Przeszukanie wprowadzonych ścieżek pod kątem istnienia szablonów, czyli plików z rozszerzeniem \emph{.tex}
    \item Załadowanie do pamięci wszystkich znalezionych szablonów pod podaną ścieżką.
    \item Przeszukanie załadowanych szablonów pod kątem informacji o selekcji danych, które mają zastać dodane do danego szablonu.
    \item Przetworzenie odpowiednio rekordów z bazy danych zgodnie z informacją zawartą w szablonach.
    \item Zapisanie wygenerowanych danych do szablonów w odpowiednich miejscach.
    \item Utworzenie i zapisanie uzupełnionych szablonów do plików o tej samej nazwie w innej podanej lokalizacji.
     \end{enumerate}
\vspace{5mm}
Cała implementacja tego procesu znajduje się w podsekcjach poniżej. 
\subsection{Składowe klasy}

Klasa powinna przechowywać podstawowe informacje takie jak:
    \begin{enumerate}
    \item \texttt{path} - Ścieżka do szablonów
    \item \texttt{pathoutput}  - Ścieżka do zapisania nowych uzupełnionych szablonów o dane.
    \item \texttt{encoding} - Kodowanie zapisu szablonów.
     \end{enumerate}

\begin{lstlisting}[numbers=left,firstnumber=30]
public class Templates {
    
 String path; 
 String pathoutput;
 String encoding;
  \end{lstlisting}
  
Deklaracje składowych tablicowych, przechowujących o plikach:
    \begin{enumerate}
    \item \texttt{listOfFiles} - Lista plików w podanej lokalizacji z rozszerzeniem \emph{.tex}
    \item \texttt{data}  - Sczytana zawartość pliku, gdzie indeks w tablicy odpowiada indeksowi w składowej \texttt{listOfFiles}
    \item \texttt{compileable} - Zmienna informująca czy plik szablonu o danym indeksie ma możliwość kompilacji.
     \end{enumerate}
  
  \begin{lstlisting}[numbers=left,firstnumber=36]
 File[] listOfFiles;
 String[] data;
 int[] compileable;
  \end{lstlisting}
  
\subsection{Konstruktor klasy}

Konstruktor klasy będzie miał ze zadanie zainicjowanie obiektu. Powinien przyjmować więc parametry o ścieżkach odczytu i zapisu szablonów jak i ich kodowania:

  \begin{lstlisting}[numbers=left,firstnumber=51]
 public Templates(String pathin, String pathout, String enc){
  \end{lstlisting}
  
  Następnie zapisanie parametrów pod składowe obiektu i sprawdzenie ich poprawności. Tworzony jest obiekt \texttt{File} ze ścieżki wynikowej, który pozwala na sprawdzenie, czy istnieje podany katalog i w razie braku tworzony jest nowy o tej nazwie.
  
  \begin{lstlisting}[numbers=left,firstnumber=54]
 path = pathin;
 pathoutput = pathout;
 encoding = enc;
 int n;
 if(path.indexOf("\\",path.length()-1) < 0 && 
  path.indexOf("/",path.length()-1) < 0){
   path = path + "\\";
  }
 if(pathoutput.indexOf("\\",pathoutput.length()-1) < 0 &&
 pathoutput.indexOf("/",pathoutput.length()-1) < 0){
  pathoutput = pathoutput + "\\";
 }
 File tmp = new File(pathoutput);
 if (!tmp.exists()) {
  tmp.mkdirs();
  }
    \end{lstlisting}
    
    
    Kolejnym krokiem będzie sprawdzenie i sporządzanie listy plików ze szablonami, znajdujących się pod ścieżką \texttt{path}. Listę tę zapiszemy pod tymczasową tablicą  \texttt{files}.
 \begin{lstlisting}[numbers=left,firstnumber=74]
 File folder = new File(path);
 File[] listOfFilestmp = folder.listFiles(); 
 n = listOfFilestmp.length;
 String[] files = new String[n];
 for (int i = 0; i < n; i++) 
 {
  if (listOfFilestmp[i].isFile()) 
  {
   test = listOfFilestmp[i].getName().indexOf(".tex");
    if(test != -1 && listOfFilestmp[i].getName().length()
    -".tex".length()-test == 0){
     files[k] = listOfFilestmp[i].getName();
     k++;
     }
    }
   }
\end{lstlisting}


Na koniec konstruktora pod składową \texttt{listOfFiles} przypisywana jest tablica o dokładnej ilości elementów, którą jest liczba szablonów. Tworzona jest także dynamiczna macierz obiektów typu \texttt{ParsedSQLInfo} do przechowywania sparsowanych informacji z szablonów. Ostatecznie tworzone są obiekty typu \texttt{File} ze ścieżki przechowującej szablony oraz całej tablicy \texttt{files} posiadającej nazwę pliku ze szablonem.
    
 \begin{lstlisting}[numbers=left,firstnumber=90]
 listOfFiles = new File[k];
 sqlinfo = new ArrayList<ArrayList<ParsedSQLInfo>>();
 for(int i=0;i < listOfFiles.length; i++)
  sqlinfo.add(new ArrayList<ParsedSQLInfo>());
 compileable = new int[k];
 data = new String[k];
 for (int i = 0; i < listOfFiles.length; i++){
  listOfFiles[i] = new File(path + files[i]);
 }
\end{lstlisting}
  
  W ten sposób otrzymywany jest zainicjalizowany obiekt, w którym należy wywołać metody ładujące szablony do pamięci z dysku.
  
  
\subsection{Metody zarządzające operacjami na plikach}

Do zapisu i odczytu potrzeba zaimplementować metody odczytujące oraz metody zapisujące szablon. Dodatkowo potrzebnym jest napisanie metod wywołujących te metody dla wszystkich szablonów. Informacje o istniejących szablonach znajdują się w tablicy \texttt{listOfFiles}. \\
\par
\subsubsection*{Ładowanie szablonu}
Potrzeba odczytać pojedynczy szablon o indeksie k i zapisać go w pamięci pod składową \texttt{data} z tym samym indeksem. 
Dodatkowo po załadowaniu szablonu wywołana zostanie metodę  \texttt{isCompilable(k)}, która sprawdzi czy jest możliwość kompilacji danego szablonu. Jest to jedna z dodatkowych funkcji programu. Metoda ta opisana została w podsekcji metod parsujących. 
 \begin{lstlisting}[numbers=left,firstnumber=121]
public void loadTemplate(int k){
       
try {
 BufferedReader in = new BufferedReader(
  new InputStreamReader(
   new FileInputStream(listOfFiles[k]), encoding));
 
  StringBuilder str = new StringBuilder();;
  String tmp;
  while ((tmp = in.readLine()) != null) {
   str.append(tmp+"\n");
   }
  in.close();
  in = null;
  data[k]=str.toString();
  System.out.println( "Loaded file: " +  listOfFiles[k].getPath());
  
 isCompilable(k);
\end{lstlisting}

\subsubsection*{Zapisywanie uzupełnionego szablonu}

Szablon zapisany pod indeksem \texttt{k} powinien zostać zapisany w miejscu przechowywanym w składowej \texttt{pathoutput} pod taką samą nazwą jak nazwa szablonu czyli \texttt{listOfFiles[k].getName()}. Dodatkowym parametrem klasy \texttt{PrintWriter} przy otwarciu pliku do zapisu jest kodowanie, które trzymane jest w składowej \texttt{encoding}. Po otwarciu pliku potrzeba zapisać zawartość składowej \texttt{data} o indeksie \texttt{k} do pliku.

 \begin{lstlisting}[numbers=left,firstnumber=171]
public void saveTemplate(int k){
      
 try {
  PrintWriter output = new PrintWriter(pathoutput + listOfFiles[k].getName(),encoding);
  output.print(data[k]);
  output.close();
  output = null;
  System.out.println( "Saved to file: "  + pathoutput +  listOfFiles[k].getName() );
}
\end{lstlisting}

\subsubsection*{Wczytanie wszystkich szablonów}

Wywołanie metody \texttt{loadTemplate(i)} dla wszystkich znalezionych szablonów.

 \begin{lstlisting}[numbers=left,firstnumber=188]
public void loadAllTemplates(){
      
 for (int i = 0; i < listOfFiles.length; i++){
  this.loadTemplate(i);
 }
}
\end{lstlisting}

\subsubsection*{Zapisanie wszystkich szablonów}

Wywołanie metody \texttt{saveTemplate(i)} dla wszystkich znalezionych szablonów.

 \begin{lstlisting}[numbers=left,firstnumber=200]
public void saveAllTemplates(){
      
 for (int i = 0; i < listOfFiles.length; i++){
  this.saveTemplate(i);
 }
       
}
\end{lstlisting}

\subsection{Metody parsujące zawartość szablonów}

Parsowanie, czyli inaczej analiza zawartości jest podstawową funkcją tego systemu. W szablonach zgodnie z wcześniej ustalonym algorytmem, znajdować się będą informacje o selekcji danych, które należy znaleźć oraz zapisać w odpowiedniej strukturze. Dodatkowo zaimplementowana zostanie także funkcja, sprawdzająca czy dany szablon może zostać skompilowany samodzielnie. 

\subsubsection*{Metoda wyszukująca informacje o selekcji we wszystkich szablonach za pomocą wzorca}

Celem metody jest przeszukanie wszystkich szablonów, używając do tego dostarczonego wzorca, pod kątem znalezienia informacji o selekcji. Następnie informacje te powinny zostać zapisane do przygotowanej składowej klasy, która może przechować te dane. 
Metoda przyjmować będzie za parametr wzorzec wyrażeń regularnych, w celu posiadania możliwości łatwej zmiany wzorca w przyszłości. Taką zmianę będzie można dokonać tylko w pliku konfiguracyjnym. 
Najważniejszym elementem tej metody jest właśnie zapisany w niej wzorzec (linia 218), za pomocą którego można znaleźć selekcje danych. Podzielony on został grupy, dzięki czemu będzie można oddzielić od siebie informacje i zapisać je w przygotowanej strukturze. Na rysunku \ref{fig:Wzorzec} przedstawiony został wzorzec. Jeżeli nie podany zostanie żaden wzorzec, użyty zostanie standardowy. 
\begin{figure}[h]
    \centering
    
    \includegraphics[width=1\textwidth]{rys/implementacja/regex.png}
    \caption{Graf przedstawiający wzorzec przechwytujący informacje o selekcji w szablonach}
    \label{fig:Wzorzec}
\end{figure}
\par
Grupy przechwytujące:
\begin{itemize}
\item Grupa 1: Nazwa środowiska
\item Grupa 2: Grupowanie
\item Grupa 3: Zapytanie SQL
\item Grupa 4: Przechwycenie pozostałości (wykorzystane tylko w celu znalezienia końca informacji)
\end{itemize}
\vspace{5mm}
 \par
W języku JAVA zaimplementowana została już obsługa wyrażeń regularnych \cite{REGEX}. Wystarczy więc wykorzystać dostępne klasy \texttt{Pattern} oraz \texttt{Matcher}. Przez wywołanie statycznej metody \texttt{compile} z flagami \texttt{Pattern.DOTALL | Pattern.MULTILINE} uzyskamy odpowiednio skompilowane wyrażenie regularne. Zewnętrzna pętla wykorzystana będzie do iterowania szablonów, natomiast wewnętrzna pętla do zapisu znalezionych selekcji dla danego szablonu. Składowa \texttt{sqlinfo} po jednorazowym wywołaniu tej metody przechowywać będzie dla k-tego szablonu wszystkie znalezione selekcje.

 \begin{lstlisting}[numbers=left,firstnumber=214]
public void parseSqlStatements(String pat)
{

 if(pat.equals(""))
  pat = "@@(?:([a-zA-Z]+)(?:@([0-9, ]+))?)?@@(.+?)@END@(.*?\\n|.*)";
    
 Pattern localPattern = Pattern.compile(pat, Pattern.DOTALL | Pattern.MULTILINE);
 Matcher localMatcher;
 for(int k=0;k < this.getLenght();k++){

  localMatcher = localPattern.matcher(this.data[k]);
  while (localMatcher.find())
  {
    sqlinfo.get(k).add(new ParsedSQLInfo(localMatcher.group(3),
    localMatcher.group(1), localMatcher.group(2), localMatcher.end()));
   }
  }
}
  \end{lstlisting}
   
\subsubsection*{Metoda sprawdzająca zdolność szablonu do kompilacji}

W czasie tworzenia projektu wynikła potrzeba wprowadzenia dodatkowej funkcji, która wykorzystywana jest w klasie odpowiadającej za kompilacje szablonów. Poniższa metoda sprawdza każdy szablon czy jest możliwe skompilowanie go, poprzez weryfikację czy wewnątrz szablonu znajduje się początek i koniec środowiska \texttt{document}. Informacje te zapisywane są odpowiednie dla k-tego szablonu w składowej klasy, która jest tablicą. Dla kompilowalnych szablonów zapisywana jest odpowiednio jedynka, natomiast dla braku możliwości kompilacji jest to zero. Wywoływana jest ona w metodzie ładowania szablonu(138 linia).

 \begin{lstlisting}[numbers=left,firstnumber=155]
 private void isCompilable(int k) {
  String start = "\\begin{document}";
  String end = "\\end{document}";
  int from = data[k].indexOf(start);
  int to = data[k].indexOf(end);
        
  if(from == -1 || to == -1)
   compileable[k] = 0;
  else
   compileable[k] = 1;
 }
  \end{lstlisting}
  
\subsection{Metody prostego przetwarzania danych z bazy}

Podsekcja opisuje proces przetwarzania danych pobranych z bazy danych do formatu, który jest w stanie odczytać kompilator LaTeX.

\subsubsection*{Metoda przygotowująca dane i wybierająca rodzaj przetwarzania}

Do metody przekazywane są następujące parametry:
\begin{itemize}
\item \texttt{int k} - Indeks pliku zapisanego w składowej
\item \texttt{int c} - Indeks selekcji ze znalezionych w danym pliku
\item\texttt{String  env} - Znaleziona nazwa środowiska dla danej selekcji
\item \texttt{String  grouping} - Znaleziona informacja o grupowaniu danych
\item \texttt{RecordSet rs} - Dane pobrane z bazy danych
\end{itemize}
\vspace{5mm}
Jeśli parametr \texttt{env} jest pusty wygenerowana zostanie nazwa środowiska za pomocą nazwy pliku oraz dodany do tego postfiks, który będzie dużą literą alfabetu łacińskiego w zależności od numeru selekcji. 
\par
Jeśli parametr \texttt{grouping} jest pusty to znaczy ze wykorzystane zostanie proste przetwarzanie poprzez wywołanie metody \texttt{prepareValuesSimple(k,c, prefix, rs);}.
\par
 W przeciwnym wypadku przygotowana zostanie tablica \texttt{int group}, 
 która zawierająca informację o ilości i wielkości wszystkich grup. Tablica ta zostanie przekazana przy wywołaniu metody, która
 przetwarza grupowanie danych \texttt{prepareValuesGrouping(group, 0,0,rs.get\_rows(),  rs, prefix)}. Metoda ta potrzebuje pewnych inicjacji w postaci parametrów 0, dlatego że jest to metoda rekurencyjna. Dokładny opis znajduje się w późniejszej sekcji.
 
 \begin{lstlisting}[numbers=left,firstnumber=246]
public int prepareValues(int k,int c,String env,String grouping,RecordSet rs){
 if(rs == null)
   return(0);

  char l = (char) ('A' + (char)c);
  String prefix;
  if(env == null)
   prefix =  listOfFiles[k].getName().substring(0,
	   listOfFiles[k].getName().indexOf('.')) + l;
  else
   prefix = env;
      
  if(grouping == null){
   prepareValuesSimple(k,c, prefix, rs);
   System.out.println(  rs.get_rows() + " records SQL" + (c+1));  
  }
  else{
   String[] groupstmp = grouping.split(",");
   int[] group = new int[groupstmp.length];
   for(int i=0;i<groupstmp.length;i++)
    group[i] = Integer.parseInt(groupstmp[i]);
           
   sqlinfo.get(k).get(c).setData(prepareValuesGrouping(
	   group, 0,0,rs.get_rows(),  rs, prefix)); 
          
   groupstmp = null;
   group = null;
   System.out.println(  rs.get_rows() + " records SQL" + (c+1));   
   rs = null;
   }
  return(0);  
 }
  \end{lstlisting}


\subsubsection*{Metoda prostego przetworzenia danych}


Metoda ma na celu utworzenie dla każdego przekazanego rekordu w parametrze metody \texttt{RecordSet rs } utworzenie linii tekstu zawierającego wywołanie środowiska o nazwie przekazanej w parametrze metody \texttt{String prefix} i od parametrów, którymi będą kolejne pola w rekordach. 
\par 
Obiekt typu \texttt{RecordSet} jest macierzą typu \texttt{String}, którą należy połączyć w odpowiedni sposób. Do tego celu wykorzystana została klasa \texttt{StringBuilder}, która potrafi połączyć znaczą ilość obiektów typu \texttt{String} w optymalny sposób poprzez metodę \texttt{append} i utworzyć z nich jeden obiekt.
\par
W odpowiedni sposób przygotowane dane zapisane zostają pod  \texttt{sqlinfo.get(k).get(c).setData(temp2); } czyli k-tym plikiem oraz c-tym zapytaniem w składowej do tego przeznaczonej.

 \begin{lstlisting}[numbers=left,firstnumber=289]
 public int prepareValuesSimple(int k,int c, String prefix, RecordSet rs){
  String temp1 = "";
  String temp2 = "";

  StringBuilder result = new StringBuilder(); 
       
  for(int i=0; i < rs.get_rows(); i++){
   temp1 = "\\" + prefix;
   for(int j=0; j < rs.get_cols(); j++)
    temp1 += "{" + rs.getVal(i, j) + "}";
        
   result.append(temp1 + "\n");
  }

  temp2 = result.toString();
  sqlinfo.get(k).get(c).setData(temp2); 
  return(0);
}
  \end{lstlisting}

\subsection{Metody grupujące dane z bazy}

Do stworzenia drzewa grup, opisanego w sekcji działania algorytmu zaimplementowana została specjalnie do tego celu rekurencyjna metoda, która wywołuje samą siebie. Ze względu na czytelność, podzielona została ona na 2 metody opisane poniżej.

\subsubsection*{Metoda rekurencyjnie generująca grupy}

Metoda przyjmuje parametry:
\begin{itemize}
\item \texttt{int[] group} - tablica grup
\item \texttt{int gid} - Indeks aktualnej grupy
\item\texttt{int s} - Numer rekordu od którego rozpoczyna pracę w tym wywołaniu w \texttt{rs record}
\item \texttt{int e} - Numer rekordu na którym kończy pracę w tym wywołaniu w \texttt{rs record}
\item \texttt{RecordSet rs} - Dane pobrane z bazy danych
\item \texttt{String prefix} - Nazwa środowiska
\end{itemize}
\vspace{5mm}
Dla aktualnej grupy i zakresu działania metoda uruchamia proste przetwarzanie danych lub w razie istnienia niższych grup, wykonuje kolejny podział na kolejną grupę poprzez analizę zawartości pól po których jest ta grupa. Dla każdej unikatowej kombinacji tworzone jest wywołanie grupy z tymi wartościami, a następnie metoda wywołuje samą siebie od zakresu w którym występują dane o unikatowych wartościach. Wywołanie w ten sposób tej metody zwróci zawartość tej grupy, która zostanie umiejscowiona pomiędzy wywołaniem grupy (startu) oraz wywołaniem zamknięcia grupy (końca).
\par 
Do nazwy grupy zgodnie z algorytmem dodawane są litery alfabetu łacińskiego w zależności od numeru poziomu grupy.
\par
Jeśli skończą się niższe grupy do utworzenia w czasie działania metody na danym zakresie danych, wywoływana jest metoda \texttt{prepareInjectValues(prefix, rs,s,e,sc)} która zwróci dla danego zakresu rekordów i wyciętych odpowiednich pól, proste wywołania środowiska o przekazanej nazwie. Wywołanie tej metody, zwróci przetworzone odpowiednio wartości, które przekazane zostaną dalej do grupy z której została wywołana metoda grupująca.

 \begin{lstlisting}[numbers=left,firstnumber=322]
 public String prepareValuesGrouping(
	 int[] group, int gid,int s, int e, RecordSet rs, String prefix){

  if(gid == group.length){
   int sc=0;
   for(int i=0;i<gid;i++)
    sc += group[i];
   return(prepareInjectValues(prefix, rs,s,e,sc));
   }
  if(gid < group.length){
   StringBuilder result = new StringBuilder(); 
   char x;
   String strreturn="";
   String strtmp="";
   String endin;
   int index1=s;
   int index2=s;
   int check=0;

   int col =0;
   for(int i=0;i<gid;i++)
    col += group[i];
          
   index2++;
   while(index2 <= rs.get_rows() && index2 <= e){
    if(index2 == rs.get_rows() || index2 == e)
     check = 2;
    else{
     for(int i=0;i<group[gid];i++)
      if(!rs.getVal(index1,i+col).equals(rs.getVal(index2,i+col)))check = 1;
    }
           
    if(check >= 1){

     x = (char) ('A' + (char)gid);
     strtmp= "\\" + prefix+x;
               
               
     for(int i=0;i<group[gid];i++)
      strtmp += "{" + rs.getVal(index1,i+col)+ "}";
               
     strtmp += "\n"; 
     strtmp += prepareValuesGrouping(group, gid+1,index1, index2, rs, prefix);
     endin =  "\\end" + prefix + x + "\n";

     result.append(strtmp.concat(endin));

     index1 = index2;
     check = 0;
    }
    index2++;
   }
  return(result.toString());    
  }
return("");
}
\end{lstlisting}


\subsubsection*{Metoda przetwarzająca dane po zgrupowaniu}


Metoda prostego już przetwarzania danych rozszerzona o dodatkowe rozróżnianie rekordów oraz pól, które ma zapisywać. 
\par 
W parametrach przekazywane są informacje:
\begin{itemize}
\item \texttt{int s} - rekord od którego rozpoczyna pracę w \texttt{rs record}
\item \texttt{int c} - rekord na którym kończy pracę w \texttt{rs record}
\item \texttt{int sc} - numer pole w rekordzie od którego ma dopiero pobierać dane, a wszystkie wcześniejsze pominąć
\item\texttt{String  prefix} -  nazwa środowiska dla danej selekcji
\item \texttt{RecordSet rs} - Dane pobrane z bazy danych
\end{itemize}
\vspace{5mm}
Metoda ostatecznie zwraca przetworzone dane. Łączenie tych danych w całość odbędzie się w metodzie \texttt{ prepareValuesGrouping} opisanej wcześniej.

 \begin{lstlisting}[numbers=left,firstnumber=380]
 private String prepareInjectValues(String prefix,RecordSet rs,int s, int e,int sc){
  String temp1 = "";
  String temp2 = "";

  StringBuilder result = new StringBuilder();

  for(int i=s; i < e; i++){
   temp1 = "\\" + prefix;
   for(int j=sc; j < rs.get_cols(); j++)
    temp1 += "{" + rs.getVal(i, j) + "}";

   temp1 += "\n";
   result.append(temp1);

      }

  return(result.toString());
}    
\end{lstlisting}


\subsection{Metoda uzupełnienia szablonu o przetworzone dane}

Metoda dodająca przetworzone wartości do zmiennej przechowującej zawartość szablonu. Dodawanie odbywa się od ostatniego zapytania do pierwszego, aby nie zmieniać dodatkowo zapamiętanych indeksów miejsc, w których znajdują się selekcje.

 \begin{lstlisting}[numbers=left,firstnumber=402]
 public void InjectValues(int k){
  int to;
  for(int i=sqlinfo.get(k).size()-1; i >= 0; i--){
    to = sqlinfo.get(k).get(i).getIndex();
    data[k] = data[k].substring(0,to) + sqlinfo.get(k).get(i).getData() 
    + data[k].substring(to,data[k].length());
   }
        
 }
\end{lstlisting}


\subsection{Akcesory}
Akcesory (gettery i settery) to określenie metod jakie wykorzystuje obiekt do pobrania wartości i modyfikacji swoich atrybutów \cite{Akcesory}. Są one bardzo często dołączane do klas przez programistów Javy i nawet niektóre edytory (np. Eclipse) posiadają funkcjonalność automatycznego wygenerowania ich. Poniżej przedstawiony został każdy akcesor do klasy z krótką informacją co pobiera:
\par
\begin{itemize}

\item Pobranie ilości szablonów:
 \begin{lstlisting}[numbers=left,firstnumber=414]
 public int getLenght(){return data.length;}
 \end{lstlisting}
 
\item Pobranie ścieżki do pliku uzupełnionego szablonu w tex:
 \begin{lstlisting}[numbers=left,firstnumber=419]
 public String getSavedPath(int k){return (pathoutput + listOfFiles[k].getName());}
     \end{lstlisting}
     
\item Pobranie ścieżki wynikowej:
 \begin{lstlisting}[numbers=left,firstnumber=423]
 public String getOutputPath(){return (pathoutput);}
     \end{lstlisting}
     
\item Pobranie informacji o tym czy k-ty szablon może zostać skompilowany:
 \begin{lstlisting}[numbers=left,firstnumber=429]
 public int compileCheck(int k){return(compileable[k]);}
     \end{lstlisting}
\item Pobranie wszystkich informacji o selekcji dla k-tego szablonu:
 \begin{lstlisting}[numbers=left,firstnumber=436]
 public ArrayList<ParsedSQLInfo> getStmts(int k){return sqlinfo.get(k);}
     \end{lstlisting}
\item Pobranie nazwy pliku o indeksie k: 
 \begin{lstlisting}[numbers=left,firstnumber=443]
 public String getFileName(int k ){ return(listOfFiles[k].getName());}
     \end{lstlisting}

\end{itemize}

\section{Zarządzanie kompilatorem LaTeX - klasa LatexCompiler}

Uzupełnione szablony przez klasę Templates, należy następnie skompilować przy pomocy wywołania kompilatora który został podany w konfiguracji.
Do tego posłuży właśnie klasa LatexCompiler, która wywoła polecenie w konsoli systemowej, uruchamiające kompilator od odpowiednich parametrów.
W składowych zapamiętane zostaną informacje o ścieżce do kompilatora oraz ścieżka plików wynikowych.

 \begin{lstlisting}[numbers=left,firstnumber=18]
public class LatexCompiler {
    
 String latexcompilerpath;
 String pdfoutput;
\end{lstlisting}

\subsubsection*{Konstruktor}
Konstruktor z 2 parametrami przekazującymi ścieżkę do kompilatora oraz katalog wynikowy, będzie miał za zadanie zapisać te parametry do składowych oraz sprawdzić czy katalog wynikowy istnieje. W razie jego braku, utworzy go.

 \begin{lstlisting}[numbers=left,firstnumber=31]
public LatexCompiler(String latexcompilerpathh,String pdfoutputt){
 latexcompilerpath = latexcompilerpathh;
 pdfoutput = pdfoutputt;

 File tmp = new File(pdfoutput);
 if (!tmp.exists()) {
  tmp.mkdirs();
 }
    
 }
\end{lstlisting}

\subsubsection*{Metoda wywołująca kompilacje pliku LaTeX}

Parametrem metody jest nazwa pliku, który zostanie poddany kompilacji.  Następnie aby skompilować dany plik należy uruchomić kompilator, do którego ścieżka zapisana jest w składowej \texttt{latexcompilerpath} z parametrem \texttt{--output-directory} w którym przekażemy katalog wynikowy oraz z parametrem którym jest ścieżka pliku do kompilacji. Wygenerowane polecenie zostanie wywołane w powłoce systemowej za pomocą metody \texttt{executeCommand} opisanej w podsekcji niżej.

 \begin{lstlisting}[numbers=left,firstnumber=46]
public int compileTemplate(String filetexpath){
 System.out.print( executeCommand(latexcompilerpath
  + " --output-directory=" + pdfoutput + " " + filetexpath));
 return(0);
 }
\end{lstlisting}

\subsubsection*{Metoda wywołująca polecenie powłoki systemu}


Metoda ta ma na celu uruchomić nowy proces, którym będzie wywołanie komendy powłoki przesłanej przez parametr \texttt{String commmand}. \texttt{Runtime.getRuntime().exec("cmd /c start" + command);} Wywoła polecenie w nowym oknie i przypnie proces do zmiennej \texttt{Process p}. Następnie aby synchronicznie wywoływać polecenie jedno po drugim, program czeka na zakończenie procesu. 

 \begin{lstlisting}[numbers=left,firstnumber=56]
private String executeCommand(String command) {
 
 StringBuffer output = new StringBuffer();
 System.out.print("Executing shell command: \n" + "cmd /c start " + command);
 Process p;
 try {
  p = Runtime.getRuntime().exec("cmd /c start " + command);
  p.waitFor();

\end{lstlisting}

\section{Metoda main() - klasa DBRaportLatex }

Metoda \texttt{main()} jest metodą od której program rozpoczyna swoją pracę. Poniżej przedstawione zostaną jej części:

\begin{itemize}

\item Przyjmuje ona argumenty, które można przekazać podczas uruchomienia programu w postaci tablicy Stringów.

 \begin{lstlisting}[numbers=left,firstnumber=38]
public static void main(String[] args) {
\end{lstlisting}
\vspace{5mm}

\item Pierwszą rzeczą którą należy zrobić po uruchomieniu programu jest załadowanie pliku konfiguracyjnego. Dodatkową opcją jest przekazanie nazwy pliku konfiguracyjnego jako pierwszy argument. Ładowanie konfiguracja odbywa się poprzez stworzenie nowego obiektu klasy \texttt{Config} przez wywołanie konstruktora z 1 parametrem, a dokładniej nazwą pliku konfiguracyjnego:

 \begin{lstlisting}[numbers=left,firstnumber=44]
 Config cfg;
        
 if(args.length == 0)
  cfg = new Config("dblatexraportconfig.bat");
 else{
  System.out.print(args[0] + "\n");
  cfg = new Config(args[0]);
 }
\end{lstlisting}
\vspace{5mm}

\item Kolejną rzeczą do zrobienia jest uzyskanie połączenia z bazą danych. Wykorzystane zostaną przy tym zmienne załadowane z pliku konfiguracyjnego poprzez wywołanie metody \texttt{getString} na obiekcie \texttt{cfg}. Do stworzenia połączenia wykorzystany zostanie obiekt klasy \texttt{DBHandle}. Po utworzeniu obiektu przez konstruktor sparametryzowany do przekazane zostaną odpowiednie zmienne konfiguracyjne, połączenie powinno zostać utworzone:


 \begin{lstlisting}[numbers=left,firstnumber=61]
 DBHandle FBH = new DBHandle(cfg.getString("dbengine"),cfg.getString("hostname"),
  cfg.getString("port"), cfg.getString("dbpath"),
  cfg.getString("dbencoding"), cfg.getString("user"),
  cfg.getString("password"));
\end{lstlisting}
\vspace{5mm}
\item Inicjalizacja obiektu zarządzającego kompilacją:

 \begin{lstlisting}[numbers=left,firstnumber=67]
 LatexCompiler comp = new LatexCompiler(cfg.getString("pdflatexpath"),
 cfg.getString("output"));
\end{lstlisting}

\vspace{5mm}
\item Inicjalizacja obiektu zarządzającego szablonami:

 \begin{lstlisting}[numbers=left,firstnumber=72]
 Templates temps = new Templates(cfg.getString("templatepath"),
  cfg.getString("output"), cfg.getString("encodingtex"));
\end{lstlisting}

\vspace{5mm}
\item Załadowanie wszystkich szablonów do pamięci za pomocą metody \texttt{loadAllTemplates();} na zainicjalizowanym odpowiednimi zmiennymi, obiekcie zarządzającym szablonami:

 \begin{lstlisting}[numbers=left,firstnumber=85]
 temps.loadAllTemplates();
\end{lstlisting}

\vspace{5mm}
\item Przygotowanie zmiennych potrzebnych do parsowania szablonów oraz wywołanie metody parsującej wszystkie szablony od wyrażenia regularnego zapisanego w pliku konfiguracyjnym (jeśli nie zostało wpisane wyrażenie regularne, użyte zostanie standardowe).

 \begin{lstlisting}[numbers=left,firstnumber=91]
 String pattern;
 pattern = cfg.getString("pattern");
 ArrayList<ParsedSQLInfo>  SQLSt;

 temps.parseSqlStatements(pattern);
\end{lstlisting}

\item Główna pętla przechodząca przez wszystkie szablony, pobierająca wszystkie polecenia selekcji z każdego szablonu. Następnie wewnętrzna pętla dla każdego polecenia wywołuje zapytanie w bazie danych i od zwróconych wyników wywołuje funkcje generującą dane do uzupełnienia w szablonie. Na koniec zewnętrznej pętli wywołanie metody uzupełniającej szablon o wygenerowane dane:

 \begin{lstlisting}[numbers=left,firstnumber=98]
 for(int i=0; i < temps.getLenght(); i++){
  System.out.print("\n");
  SQLSt = temps.getStmts(i);
      
  if(SQLSt != null){
   System.out.println(temps.getFileName(i) + " - processing SQL statements");
   for(int j=0; j < SQLSt.size(); j++){

                
    if(SQLSt.get(j).getName() == null){
     System.out.println("no returns SQL" + (j+1)); 
                 
     FBH.executeSQL2(SQLSt.get(j).getQuery());
                
     }
     else
                  
      temps.prepareValues(i,j,SQLSt.get(j).getName(),
      SQLSt.get(j).getGroup(),FBH.executeSQL2(SQLSt.get(j).getQuery()));
    }
   }
 temps.InjectValues(i);
 SQLSt = null;
 } 
\end{lstlisting}


\vspace{5mm}
\item Zapisanie wszystkich uzupełnionych szablonów do plików:

 \begin{lstlisting}[numbers=left,firstnumber=124]
 temps.saveAllTemplates();
\end{lstlisting}
       
\vspace{5mm}
\item Na koniec przeprowadzenie kompilacji uzupełnionych szablonów w zależności od zmiennej \texttt{pdfcompilemainfile} używając przygotowanego obiektu \texttt{comp} klasy \texttt{LatexCompiler}.

       
\begin{lstlisting}[numbers=left,firstnumber=126]
       
 if(cfg.getString("pdfcompilemainfile").equals("ALL"))
  for(int i=0; i < temps.getLenght(); i++){
   comp.compileTemplate(temps.getSavedPath(i));
   }
 if(cfg.getString("pdfcompilemainfile").equals("ONLYBEGDOC"))
  for(int i=0; i < temps.getLenght(); i++){
   if(temps.compileCheck(i)==1)
    comp.compileTemplate(temps.getSavedPath(i));
    }
      
 else if(cfg.getString("pdfcompilemainfile").equals("NONE"));
 else{
          
  String[] tmpfiles = cfg.getString("pdfcompilemainfile").split(",");
          
  for(int i=0;i < tmpfiles.length; i++)
    comp.compileTemplate(temps.getOutputPath() + tmpfiles[i].trim());
  
 }
\end{lstlisting}

\end{itemize}
\section{Kompilacja programu}

Do kompilacji programu dołączony jest plik \emph{build.xml}. Opisuje on przebieg pakowania pliku jar. Ze względu na wykorzystanie paru zewnętrznych bibliotek, tworzony był katalog \emph{library} zawierający te biblioteki i aby tego uniknąć zastosowana została funkcja pakująca wszystkie biblioteki do jednego pliku jar. W listingu poniżej pokazana jest konfiguracja pliku \emph{build.xml}:

 \begin{lstlisting}
 <?xml version="1.0" encoding="UTF-8"?>

<project name="DBRaportLatex" default="default" basedir=".">
    <description>Builds, tests, and runs the project DBRaportLatex.</description>
    <import file="nbproject/build-impl.xml"/>
<target name="-post-jar">

    <property name="store.jar.name" value="DBRaportLatex"/>

    <property name="store.dir" value="dist"/>
    <property name="store.jar" value="${store.dir}/${store.jar.name}.jar"/>

    <echo message="Packaging ${application.title} into a single JAR at ${store.jar}"/>

    <jar destfile="${store.dir}/temp_final.jar" filesetmanifest="skip">
        <zipgroupfileset dir="dist" includes="*.jar"/>
        <zipgroupfileset dir="dist/lib" includes="*.jar"/>

        <manifest>
            <attribute name="Main-Class" value="${main.class}"/>
        </manifest>
    </jar>

    <zip destfile="${store.jar}">
        <zipfileset src="${store.dir}/temp_final.jar"
        excludes="META-INF/*.SF, META-INF/*.DSA, META-INF/*.RSA"/>
    </zip>

    <delete file="${store.dir}/temp_final.jar"/>
    <delete dir="${store.dir}/lib"/>
    <delete file="${store.dir}/README.TXT"/>
</target>
  
</project>
\end{lstlisting}


